# 2주차 강의자료 정리

## 자료구조
### 배열

> 메모리 상에 원소를 연속하게 배치한 자료구조

자바 상에서는 배열의 길이를 변경하는게 불가능 하지만 자료구조로써는 배열의 길이를 늘리거나 줄일 수 있다고 생각할께요!

**성질**

1. O(1)에 k번쨰 원소를 확인/변경 가능
2. 추가적으로 소모되는 메모리의 양(오버헤드)가 거의 없음
3. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

**설명**

맨 끝에 자료를 추가/제거하는 구조일 때는 O(1)의 시간 복잡도를 갖음

But. 임의에 위치에 원소 추가시 O(N)

---

### 연결리스트
연결리스트의 성질

1. K번째 원소를 확인/ 변경하기 위해 O(k)가 필요함
2. 임의의 위치에 원소를 추가/임의 위치의 원소제거는 O(1)
3. 원소들이 메모리 상에 연속해 있지 않아 Cache hit rate가 낮다
4. 새로 할당이 쉬운 편

연결 리스트의 종류
**단일 연결 리스트**
이중 **연결 리스트**
원형 **연결 리스트**


연결리스트의 대표 예시로는 메모장이 있습니다.

배열 vs 연결 리스트(LinkedList)

|                            | 배열 | 연결리스트 |
|----------------------------| --- | --- |
| N번째 원소의 접근                 | O(1) | O(N) |
| 임의 위치에 원소 추가/제거            | O(N) | O(1) |
| 메모리 상의 배치                  | 연속 | 불연속 |
| 추가적으로 필요한 공간<br>(overhead) | - | O(N) |

LinkedList vs ArrayList

|  | ArrayList                        | 연결리스트 |
| --- |----------------------------------| --- |
| 읽기(접근시간) | 빠르다                              | 느리다 |
| 추가/삭제 | 느리다                              | 빠르다 |
| 비 고 | 순차적인 추가삭제는 더 빠름.<br>비효율적인 메모리 사용 | 데이터가 많을 수록 접근성이 떨어짐 |
| 시간복잡도 |                                  |  |
| 마지막위치에 원소 추가 | O(1)                             | O(1) |
| 임의 위치에 원소 추가/제거 | O(N)                             | O(1) |
| 임의 위치 접근(색인) | O(1)                             | O(N) |
___

### 스택

### 큐
### 덱
### 우선순위 큐

### 해시

- 해시는 내부적으로 배열을 사용하여 데이터를 저장. 빠른 검색 속도를 가짐
- 데이터 삽입, 삭제시 밀어내거나 채우는 작업이 없이 고유 인덱스로 데이터를 저장함.

**key를** **hash function을 통해 hash값으로 바꾼뒤**이 **hash값을 index로 사용해 key - value 형식으로** 저장하는 자료구조.

hash table은 **순서없이 key - value로만 값을 저장하기 때문에 순서가 필요한 데이터에는 비적합.**

순차적인 저장을 하는 배열 인덱스와 달리 전 영역에 분포되어 저장.

장점
- key - value 1대1 구조로 삽입,검색, 삭제, 모두 평균 O(1)의 복잡도를 가짐.

단점
- 공간효율성 떨어짐. ( 데이터 저장 전 공간 생성.)
- 순서 보장 x ( hash function이 index를 정함.)
- hashFunction 의존도가 높다.( 함수가 복잡하다면 hash 생산 소요시간이 길어짐. )
- 최악의 케이스는 O(n)의 시간 복잡도를 가짐.